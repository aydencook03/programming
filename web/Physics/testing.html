<html>
<meta name='viewport' content='width=device-width,height=device-height'>
<script>

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// event handling

document.addEventListener('keydown', keyDown);
document.addEventListener('mousedown', mouseDown)
document.addEventListener('mouseup', mouseUp)
document.addEventListener('mousemove', mouseMove);
document.addEventListener('touchstart', touchStart);
document.addEventListener('touchmove', touchMove);
document.addEventListener('touchend', touchEnd);
window.addEventListener('resize', resize);
window.onload = function() {reset()}

mouseDown = false;
nothingGrabbed = true;
mouseX = 0;
mouseY = 0;

function keyDown(data) {
    if(data.key == "r") {
        clearInterval(loop);
        reset();
    }
    else if(data.key == 'g') {
        gravityOn = !gravityOn;
    }
    else if(data.key == 'Delete') {
        for(i = 0; i < bodies.length ; i++) {
            if(((mouseX - bodies[i].x)**2 + (mouseY - bodies[i].y)**2) <= bodies[i].radius**2) {
                bodies.splice(i, 1);
            }
        }
    }
    else if(data.key == 'c') {
        gravity_c *= -1;
    }
    else if(data.key == 'f') {
        falling = !falling;
    }
    else if(data.key == 'a') {
        acceleration *= -1;
    }
    else if(data.key == 'n') {
        Body.create();
    }
}
function mouseDown(data) {
    mouseDown = true;
    nothingGrabbed = true;
    mouseX = data.clientX;
    mouseY = canvas.height - data.clientY;
}
function mouseUp(data) {
    mouseDown = false;
    nothingGrabbed = true;
    for(let i = 0; i < bodies.length; i++) {
        bodies[i].grabbed = false
    }
}
function mouseMove(data) {
    mouseX = data.clientX;
    mouseY = canvas.height - data.clientY;
}
function touchStart(data) {
    mouseDown = true;
    nothingGrabbed = true;
    mouseX = data.touches[0].clientX;
    mouseY = canvas.height - data.touches[0].clientY;
}
function touchMove(data) {
    mouseX = data.touches[0].clientX;
    mouseY = canvas.height - data.touches[0].clientY;
}
function touchEnd(data) {
    mouseDown = false;
    nothingGrabbed = true;
    for(let i=0;i<bodies.length;i++) {
        bodies[i].grabbed = false;
    }
}
function resize(data) {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialize Variables

function reset() {
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    canvas.color = 'rgb(70, 70, 70)';
    
    scale = Math.min(canvas.width, canvas.height);
    
    
    fps = 120;
    running = true;
    
    
    loop = setInterval(main, 1000/fps);

    
    gravityOn = true // if true, objects are gravitationally attracted to each other
    gravity_c = 334000 // universe's gravitational constant

    boundaryCollision = true // if true, objects collide with edges of canvas
    wallDampen = 0.7 // number to multiply by when an objects hit a wall

    bodyCollision = true // if true, bodies will collide with each other
    bodyDampen = 0.4 // number to multiply when two objects collide

    falling = false // if true, objects will fall to the bottom of the screen
    acceleration = 400 // rate at which objects fall
    
    Body.clear() // clears all bodies
    
    /*
    const bounds = 200;
    for(let i = 0; i<70; i++) { // randomly place bodies
        Body.create({
            x: Math.floor(Math.random()*canvas.width),
            y: Math.floor(Math.random()*canvas.height),
            a: Math.random()*Math.PI*2,
            xV: Math.floor(Math.random() * (bounds - -bounds)) + -bounds,
            yV: Math.floor(Math.random() * (bounds - -bounds)) + -bounds,
            mass: Math.ceil(Math.random()*23)
        })
    } */
    
    Body.create({
        x: canvas.width/2,
        y: canvas.height/2,
        color: 'crimson',
        mass: 100
    })
    Body.create({
        mass: 20,
        radius: 10,
        color: 'teal',
        x: bodies[0].x + bodies[0].radius + 10
    })
    
    /*
    Body.create({
        x: canvas.width/2 - 50,
        xV: 10,
        yV: 0,
        aV: 3,
        y: canvas.height/2 + 0,
        mass: 10
    });
    Body.create({
        x: canvas.width/2 + 50,
        xV: 0,
        aV: 0,
        y: canvas.height/2,
        mass: 10
    });
    
    */
    
    
    /*
    Body.create({
    x: canvas.width/2, 
    y: canvas.height/2, 
    mass: 24, 
    xV: -10.83
    });
    Body.create({
    x: canvas.width/2, 
    y: canvas.height/2 + 150, 
    mass: 1, 
    xV: 260, 
    color: 'teal'
    }); */
    
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Body Type Object

function Body(params) {
    this.x = params.x || canvas.width/2;
    this.y = params.y || canvas.height/2;
    this.a = params.a || 0;
    
    this.xV = params.xV || 0;
    this.yV = params.yV || 0;
    this.aV = params.aV || 0;
    
    this.xA = params.xA || 0;
    this.yA = params.yA || 0;
    this.aA = params.aA || 0;
    
    this.grabbed = false;
    
    this.edgeBlock = params.edgeBlock || boundaryCollision;
    
    this.gravity = params.gravityOn || gravityOn;
    
    this.mass = params.mass || 6;
    this.density = params.density || 0.008;
    this.radius = params.radius || (this.mass/(Math.PI*this.density))**0.5;
    this.color = params.color || 'crimson';
    this.lineWidth = params.lineWidth || 2;
}

Body.create = function(params) { // utility function
    if(typeof bodies === 'undefined') {
        bodies = [];
    }
    if(typeof params === 'undefined') {
        params = {};
    }
    return bodies.push(new Body(params));
}

Body.clear = function() { // utility function
    return bodies = [];
}

Body.prototype.move = function() { // available to all instances, but not a part of them
    this.xV += this.xA/fps;
    this.yV += this.yA/fps;
    this.aV += this.aA/fps;
    this.x += this.xV/fps;
    this.y += this.yV/fps;
    this.a += this.aV/fps;
    
    if(this.edgeBlock) {
        if(this.x + this.radius > canvas.width) {
            this.x = canvas.width - this.radius;
            this.xV *= -wallDampen
        }
        else if(this.x - this.radius < 0) {
            this.x = this.radius;
            this.xV *= -wallDampen;
        }
        if(this.y + this.radius > canvas.height) {
            this.y = canvas.height - this.radius;
            this.yV *= -wallDampen;
        }
        else if(this.y - this.radius < 0) {
            this.y = this.radius;
            this.yV *= -wallDampen;
        }
    }
    if(this.grabbed) {
        this.xA = 0;
        this.yA = 0;
        this.xV = 0;
        this.yV = 0;
        this.x = mouseX;
        this.y = mouseY;
    }
}

Body.prototype.draw = function() { // available to all instances, but not a part of them
    ctx.beginPath();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = this.lineWidth;
    ctx.fillStyle =  this.color;
    ctx.arc(this.x, canvas.height - this.y, this.radius, 0, Math.PI*2, true);
    ctx.fill();
    ctx.stroke();
    ctx.closePath()
    
    ctx.beginPath();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = this.linewidth;
    ctx.moveTo(this.x, canvas.height - this.y);
    ctx.lineTo(this.x + this.radius*Math.cos(this.a), canvas.height - (this.y + this.radius*Math.sin(this.a)))
    ctx.stroke();
    ctx.closePath();
}

// calculates gravitational attraction to 'otherObject'
Body.prototype.gravityCalc = function(otherObject) { // available to all instances, but not a part of them
    const x1 = this.x;
    const y1 = this.y;
    const x2 = otherObject.x;
    const y2 = otherObject.y;
    const distSquare = ((x2-x1)**2 + (y2-y1)**2);
    const val = (gravity_c*otherObject.mass)/((distSquare)**(3/2));
    const xA = val * (x2 - x1);
    const yA = val * (y2 - y1);
    
    return [xA, yA]
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Physics Code

const drawMove = function() {
    for(let i=0 ; i<bodies.length; i++) {
        
        if(mouseDown && nothingGrabbed) {
            if(Math.abs((mouseX - bodies[i].x)**2 + (mouseY - bodies[i].y)**2) <= bodies[i].radius**2) {
                bodies[i].grabbed = true;
                nothingGrabbed = false;
            }
        }
        
        if(falling) {
            bodies[i].yA -= acceleration;
        }
        
        bodies[i].draw();
        
        if(running) {
            bodies[i].move();
        }
    }
}

const collision = function() {
    if(bodyCollision) {
        let collidingPairs = [];
        for(let i=0; i<bodies.length; i++) {
            
            //static
            for(let b=0; b<bodies.length; b++) {
                if(i != b) {
                    const x1 = bodies[i].x;
                    const y1 = bodies[i].y;
                    const x2 = bodies[b].x;
                    const y2 = bodies[b].y;
                    const rSum = bodies[i].radius + bodies[b].radius;
                    const dist = { // vector
                        i: x2 - x1,
                        j: y2 - y1,
                        mag: ((x2-x1)**2 + (y2-y1)**2)**0.5,
                        norm: {
                            i: (x2-x1)/(((x2-x1)**2 + (y2-y1)**2)**0.5),
                            j: (y2-y1)/(((x2-x1)**2 + (y2-y1)**2)**0.5)
                        }
                    }
                    if(dist.mag <= rSum) { // static collision
                        const overlap = rSum - dist.mag;
                        bodies[i].x -= overlap/2 * dist.norm.i;
                        bodies[i].y -= overlap/2 * dist.norm.j;
                        bodies[b].x += overlap/2 * dist.norm.i;
                        bodies[b].y += overlap/2 * dist.norm.j;
                        
                        collidingPairs.push([bodies[i], bodies[b]]);
                    }
                }
            }
            
            // dynamic
            for(let c = 0; c < collidingPairs.length; c++) {
                const x1 = collidingPairs[c][0].x;
                const y1 = collidingPairs[c][0].y;
                const r1 = collidingPairs[c][0].radius;
                const x2 = collidingPairs[c][1].x;
                const y2 = collidingPairs[c][1].y;
                const r2 = collidingPairs[c][1].radius;
                const dist = { // vector from b1 to b2
                        i: x2 - x1,
                        j: y2 - y1,
                        mag: ((x2-x1)**2 + (y2-y1)**2)**0.5,
                        norm: {
                            i: (x2-x1)/(((x2-x1)**2 + (y2-y1)**2)**0.5),
                            j: (y2-y1)/(((x2-x1)**2 + (y2-y1)**2)**0.5)
                        }
                }
                const m1 = collidingPairs[c][0].mass;
                const m2 = collidingPairs[c][1].mass;
                
                const norm = { // vector normal along 'wall' of collision
                    i: -dist.j/(((dist.i)**2 + (-dist.j)**2)**0.5),
                    j: dist.i/(((dist.i)**2 + (-dist.j)**2)**0.5)
                }
                const perp = { // vector normal pointing from b1 to b2
                    i: dist.norm.i,
                    j: dist.norm.j
                }
                
                const vel1 = { // vector of b1 velocity
                    i: collidingPairs[c][0].xV,
                    j: collidingPairs[c][0].yV,
                    dot: function(vect) {
                        return collidingPairs[c][0].xV * vect.i + collidingPairs[c][0].yV * vect.j
                    }
                }
                const vel2 = { // vector of b2 velocity
                    i: collidingPairs[c][1].xV,
                    j: collidingPairs[c][1].yV,
                    dot: function(vect) {
                        return collidingPairs[c][1].xV * vect.i + collidingPairs[c][1].yV * vect.j
                    }
                }
                
                // new velocities along perp^ of b1 and b2
                const nV1Perp = (vel1.dot(perp))*(m1-m2)/(m1+m2) + (vel2.dot(perp))*(2*m2)/(m1+m2);
                const nV2Perp = (vel1.dot(perp))*(2*m1)/(m1+m2) + (vel2.dot(perp))*(m2-m1)/(m1+m2);
                
                collidingPairs[c][0].xV = vel1.dot(norm)*norm.i + nV1Perp*perp.i * bodyDampen;
                collidingPairs[c][0].yV = vel1.dot(norm)*norm.j + nV1Perp*perp.j * bodyDampen;
                
                collidingPairs[c][1].xV = vel2.dot(norm)*norm.i + nV2Perp*perp.i * bodyDampen;
                collidingPairs[c][1].yV = vel2.dot(norm)*norm.j + nV2Perp*perp.j * bodyDampen;
            }
        }
    }
}

const gravity = function() {
    for(let i=0; i<bodies.length; i++) {
        bodies[i].xA = 0;
        bodies[i].yA = 0;
        if(bodies[i].gravity && gravityOn) {
            for(let b=0; b<bodies.length; b++) {
                if(i != b) {
                    const accel = bodies[i].gravityCalc(bodies[b]);
                    bodies[i].xA += accel[0];
                    bodies[i].yA += accel[1];
                }
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Main Loop

const main = function() {
    // blank out canvas
    ctx.fillStyle = canvas.color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawMove();
    collision();
    gravity();
    if(nothingGrabbed && mouseDown) {
        Body.create({
            x: mouseX, 
            y: mouseY, 
            mass: 90});
        bodies[bodies.length-1].move();
        bodies[bodies.length-1].draw();
    }
}



</script>
<body>
<canvas id="canvas" width='300px' height='300px'></canvas>
<style>
body {
    padding: 0;
    margin: 0;
}
canvas {
    padding: 0;
    margin: 0;
}
</style>
</html>
